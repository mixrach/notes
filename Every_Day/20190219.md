关于token失效刷新的思考

一般系统会根据给定的认证信息授予调用方一个accessToken，而此accessToken有一定的过期时间，在我们的系统中如何维护这样一个token是一个问题。

最简单的想法或者说策略是，将token放入redis中，而redis的过期时间小于服务方给定的过期时间，这样，如果一个线程获取redis中的token失败，此线程将请求服务提供方获取新的token，并将token放入redis中。

乍一看这样的逻辑通顺着呢。但是我们忘记考虑了一个关键点，即并发。当有多个线程同时发现redis中的token失效时，他们都会去请求服务提供方获取token，显然这样是不能够的。为了避免这种情况，我们添加一个补丁方案，即加一个分布式锁。基本方案是，在一个线程发现token失效时，获取一个分布式锁，并请求获取新的token，其他线程也发现token失效且获取不到锁时，要么直接返回失败，要么sleep一段时间重新获取token或锁。

上面基于redis的解决方案是可行的。也有实践的案例。但是我觉得还是存在一些问题，最明显的点是，上述获取不到锁的线程的行为是不好定义的。如果直接返回失败未免太草率了点，而如果sleep一段时间，则会带来连接一直被占用等资源浪费的情况。此外，如果分布式锁出了问题，比如获取到锁的线程挂掉了，并没有成功的释放锁，我们虽然可以设置一个锁的过期时间，但是不论怎样，在这段时间内，这个服务算是废掉了。

前面提到的线程行为不好定义，对于这一点，我们可以使用mysql数据库代替redis，使用行锁代替分布式锁。这样，多个线程之间竞争同一个行锁，获取不到锁的线程，则因为与数据库会话一直没有相应而一直被阻塞，直到数据更新并且写锁被释放，诸多线程可以读取其数据。这也是很可行的一个方案。好处是我们不用处理等待token更新线程的状态，直接依赖操作系统的调度即可。

然而，这里也是有一个致命的问题，如果一个线程获取到此行数据的读锁之后一直被阻塞或者挂起，则这段时间内服务也是不可用的，而且也会存在连接数消耗过大等资源浪费，除非在我们发现获取不到读锁就直接返回。但这个通常不是在我们的应用程序中控制，而是在数据库层面控制，除非我们在代码中添加这些获取锁的操作。

以上的方案，都是基于锁，实现token失效时自动刷新的功能。其弊端主要体现在两个方面，一是锁有可能不被正常释放，这时会导致一段时间内服务不可用。而是即便可以被正常释放，根据我们的策略不同，如果获取失败则直接返回失败，则必然会存在一段时间（获取新token的时间）服务是不可用的，如果获取失败则等待，则会导致在这段时间内资源被严重浪费，用户端的迟迟得不到响应，且大并发情况下，用户连接得不到快速的释放，导致服务的qps急剧降低，从而发生事故。

为了规避此问题，还有一种理论上更好的解决方案。即通过一个外部的token刷新服务负责token的更新工作，而业务系统只负责获取token后请求服务提供方即可。这样的好处主要体现在，一是职责分离的很清晰，二是，我们通过一个定时任务，通常由任务调度系统负责，去刷新token。而任务调度系统定是高可用的，而且任务执行系统只负责token的刷新工作，与高并发的用户请求基本上没有关系，所以理论上它也是高可用的。所以分析下来，通过这样外部刷新token的方式，一般不会导致token不存在或者失效等带来的服务不可用。退一万步讲，即便是token刷新服务挂了，我们也能够根据监控第一时间获取到这个情况。从概率上讲，服务挂的时间节点导致使用token的服务不可用的机会不大，即便是恰好在边界时间发生了故障，我们也很好的使用手工补偿（手动刷新token）的方案去刷新token，同时我们也有足够的时间去解决服务挂掉的问题。

这种方案的弊端也很明显，诸多的token刷新都依赖于此服务的可用，有点把所有鸡蛋放在一个篮子里的感觉，但我们分析下来，可以肯定的是，这个篮子是一个铁篮子，不会出问题的篮子。

