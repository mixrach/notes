# Why MQ?
## 解耦
在项目启动之初来预测将来项目会碰到什么需求，是极其困难的。消息系统在处理过程中间插入了一个隐含的、基于数据的接口层，两边的处理过程都要实现这一接口。这允许你独立的扩展或修改两边的处理过程，只要确保它们遵守同样的接口约束。

## 冗余
有些情况下，处理数据的过程会失败。除非数据被持久化，否则将造成丢失。消息队列把数据进行持久化直到它们已经被完全处理，通过这一方式规避了数据丢失风险。许多消息队列所采用的"插入-获取-删除"范式中，在把一个消息从队列中删除之前，需要你的处理系统明确的指出该消息已经被处理完毕，从而确保你的数据被安全的保存直到你使用完毕。

## 扩展性
因为消息队列解耦了你的处理过程，所以增大消息入队和处理的频率是很容易的，只要另外增加处理过程即可。不需要改变代码、不需要调节参数。扩展就像调大电力按钮一样简单。

## 灵活性 & 峰值处理能力
在访问量剧增的情况下，应用仍然需要继续发挥作用，但是这样的突发流量并不常见；如果为以能处理这类峰值访问为标准来投入资源随时待命无疑是巨大的浪费。使用消息队列能够使关键组件顶住突发的访问压力，而不会因为突发的超负荷的请求而完全崩溃。

## 可恢复性
系统的一部分组件失效时，不会影响到整个系统。消息队列降低了进程间的耦合度，所以即使一个处理消息的进程挂掉，加入队列中的消息仍然可以在系统恢复后被处理。

## 顺序保证
在大多使用场景下，数据处理的顺序都很重要。大部分消息队列本来就是排序的，并且能保证数据会按照特定的顺序来处理。

## 缓冲
在任何重要的系统中，都会有需要不同的处理时间的元素。该缓冲有助于控制和优化数据流经过系统的速度。

## 异步通信
很多时候，用户不想也不需要立即处理消息。消息队列提供了异步处理机制，允许用户把一个消息放入队列，但并不立即处理它。想向队列中放入多少消息就放多少，然后在需要的时候再去处理它们。

# 特点对比

消息队列|RabbitMQ|kafka|RocketMQ
:----|---|---|---:
设计目的|消息路由，分发|分布式流处理|两者兼顾
性能(单机吞吐量)|10K|100k~1000K|100K
可靠性|消息持久化，ACK(C,P),镜像部署等|异步刷盘，异步Replication/同步Replication，集群部署|支持异步实时刷盘，同步刷盘，同步/异步Replication 
消息批量操作| 不支持| 支持| 支持
消息分发方式| Queue push | Consumer  pull | Push&Pull 
消息堆积&持久化|buffer堆积，支持队列和消息持久化，但会影响性能|磁盘文件|磁盘文件
开发语言|Erlang|Scala&Java|Java
协议支持|AMQP，XMPP，SMTP等|自有协议|自有协议
消息有序性|若要保证有序，只能有一个client|支持Partition中消息有序，宕机后乱序|支持严格的消息顺序
事务|支持，但是性能极差（推荐使用Comfirm机制）|支持|最新版本支持
负载均衡|支持|支持|支持
生态工具|成熟的管理工具|命令行操作，yahoo kafka manager|官方命令行，开源管理工具

# 部署方式
## RabbitMQ
![](/img/rabbitmq/architecture.png) 
## Kafka
![](/img/kafka/kafka_architecture.png)
## RocketMQ
![](/img/RocketMQ/推荐架构.png)

概念解释：
> - 同步刷盘: 当数据写如到内存中之后立刻刷盘(同步)，在保证刷盘成功的前提下响应client。
> - 异步刷盘: 数据写入内存后，直接响应client。异步将内存中的数据持久化到磁盘上。

> - 异步Replication: 事务提交后才进行同步
> - 同步Replication: 同步完成后事务才能提交成功



